	TITLE	'PROGRAM SERIALIZATION FOR CP/M 2.2 2/80'

VERSION	=	22		;CPM version number


;	PROGRAM SERIALIZATION FOR CP/M DISKETTES
;
;	THIS PROGRAM CONTAINS DIGITAL RESEARCH PROPRIETARY INFORMATION,
;	AND MUST NOT BE REPRODUCED, COPIED, OR TRANSCRIBED IN ANY FORM
;	WHATSOEVER
;
;	Modified for CompuPro by:
;		R.H. Frank
;		Sorcim Corporation
;		April 6, 1981
;
;	COPYRIGHT (C) 1976, 1977, 1978, 1979, 1980
;	Author:
;		DIGITAL RESEARCH
;		BOX 579 PACIFIC GROVE
;		CALIFORNIA, 93950
;	Origin # expanded to 16 bits 03 Nov 80 JRP.



;	GLOBAL EQUATES
BOOT	EQU	0000H
BDOS	EQU	0005H
CONIN	EQU	1		;READ CONSOLE DEVICE
RDBUFF	EQU	10		;READ BUFFER
PBUFF	EQU	9		;PRINT BUFFER
CR	EQU	0DH
LF	EQU	0AH

;	CCP-DBOS track
LTRK	=	256		;Double density
NSEC	=	26		;52 single length
TRLEN	=	LTRK*NSEC	;max track length
CCPTRK	=	1		;CCP track
CCPB	EQU	2900H		;CONSOLE PROCESSOR BASE
BDOSB	EQU	3100H		;BASIC DOS BASE
OFFSET	EQU	0		;SPACE FOR COLD BOOT ON DISK
SLEN	EQU	BDOSB-CCPB	;SEARCH LENGTH FOR SERIAL NUMBER

TPA	EQU	100H		;TRANSIENT PROGRAM AREA
MOVTRK	=	3		;1st user track for CPM

;	OEM's origin number defined by CPM Digital Research
OEMSN	=	272
OEMN1	=	'2'
OEMN2	=	'7'
OEMN3	=	'2'		;Never to change with duping system



;	UTILITY SUBROUTINES FOR DIRECT DISK IO
WBOOT	EQU	1		;WARM BOOT ADDRESS
SELDSK	EQU	24		;SELECT DISK
SETTRK	EQU	27		;SET TRACK
SETSEC	EQU	30		;SET SECTOR
SETDMA	EQU	33		;SET DMA ADDRESS
READF	EQU	36		;READ DISK
WRITF	EQU	39		;WRITE DISK
	page



	ORG	TPA
	JMP	START
	DB	'COPYRIGHT (C) 1980, DIGITAL RESEARCH '


TRACK:	DS	1	;SET TO TRACK TO READ/WRITE
BUFFA:	DS	2	;SET TO BUFFER ADDRESS TO READ/WRITE
IOF:	DS	1	;IO FUNCTION 0 = READ, 1 = WRITE
	page
RDSK:	;READ DISK DRIVE A, FROM TRACK 'TRACK'
;	INTO THE ADDRESS GIVEN BY 'BUFFA'
	XRA	A
	CALL	SEL		;SELECT DRIVE A
	JMP	REDSK2


WDSK:	;WRITE TO DISK DRIVE B, TO TRACK 'TRACK'
;	FROM THE ADDRESS GIVEN BY 'BUFFA'
	LDK	A,1
	STA	IOF		;SET IOFUNCTION TO WRITE
	CALL	SEL		;SELECT DRIVE B
	JMP	REDSK4


REDSK:	;READ FROM DISK DRIVE B, FROM TRACK 'TRACK'
;	TO THE ADDRESS GIVEN BY 'BUFFA'
	LDK	A,1
	CALL	SEL		;DRIVE B SELECTED
REDSK2:	XRA	A
	STA	IOF		;SET TO READ FUNCTION
REDSK4:	;READ OR WRITE DISK
	LDK	HL,TRACK
	MOV	C,M		;GET TRACK NUMBER
	CALL	TRK		;TRACK SELECTED
	LD	HL,TRKDEF
	EX	DE,HL
	LD	HL,BUFFA	;GET DMA ADDRESS

RWLOP:	;READ/WRITE LOOP
;	D= sector to read or write
;	E= number of sectors remaining
	INR	D		;TO NEXT SECTOR
	PUSH	D
	PUSH	H
	MOV	C,D
	CALL	SEC		;SECTOR SET
	POP	B
	PUSH	B		;GET DMA ADDRESS
	CALL	DMA		;DMA ADDRESS SET

;	PERFORM IO FUNCTION
	LDA	IOF
	ORA	A		;SET FLAGS, 0=READ, 1=WRITE
	JNZ	WRTFNC
	CALL	DREAD		;read disk
	JMP	RWCOMPLETE

WRTFNC:	;Perform write to disk
	CALL	DWRITE		;write disk
RWCOMPLETE:			;FUNCTION COMPLETE
	POP	H		;RECALL DMA ADDRESS
	LXI	D,80H
	ADD	HL,DE		;TO NEXT DMA
	POP	D		;RECALL SECTOR AND COUNT
	ORA	A
	RNZ			;If error, Exit
	DCR	E		;COUNT = COUNT - 1
	JNZ	RWLOP		;FOR ANOTHER SECTOR
	RET			;WITH ZERO FLAG SET FOR IO COMPLETE
	page
;	Cbios function processors


SEL:	;SELECT DRIVE GIVEN BY REGISTER A
	MOV	C,A
	LD	HL,WBOOT
	LXI	D,SELDSK
	ADD	HL,DE
	LDK	E,0		;force flush and select
	JMP	[hl]

TRK:	;SET TRACK GIVEN BY C
	LD	HL,WBOOT
	LXI	D,SETTRK
	ADD	HL,DE
	JMP	[hl]

SEC:	;SET SECTOR GIVEN BY C
	LD	HL,WBOOT
	LXI	D,SETSEC
	ADD	HL,DE
	JMP	[hl]

DMA:	;SET DMA ADDRESS TO VALUE OF B,C
	LD	HL,WBOOT
	LXI	D,SETDMA
	ADD	HL,DE
	JMP	[hl]

DREAD:	;PERFORM READ OPERATION
	LD	HL,WBOOT
	LXI	D,READF
	ADD	HL,DE
	JMP	[hl]

DWRITE:	;PERFORM WRITE OPERATION
	LD	HL,WBOOT
	LXI	D,WRITF
	ADD	HL,DE
	JMP	[hl]
	page
;	Main loop for Copy program


START:	LXI	SP,STACK
	CALL	ORGMSG		;ORIGIN PROMPT
	LDK	HL,0FF00h or NSEC
	STO	HL,TRKDEF	;set track-sec def for Track 0
	LDK	BC,OEMSN	;fixed origin number
	LDK	HL,ORIGIN
	STO	C,[hl]
	INC	HL
	STO	B,[hl]		;save OEM origin number

;	NOW READ THE SERIAL NUMBER
	CALL	SERMSG
	CALL	GNUM
	LDK	HL,B_SN
	MOV	M,C
	INC	HL
	MOV	M,B		;BINARY COPIED
	LDK	HL,COMLEN
	LDK	A,5
	SUB	M		;DIFFERENCE IN REG-A
	LDK	HL,A_SN
	JZ	PAD1		;PAD HIGH ORDER POSITIONS WITH 0
PAD0:	MVI	M,'0'
	INC	HL
	DEC	A
	JNZ	PAD0
PAD1:	LXI	D,CBUFF		;ADDRESSING BUFFER
PAD2:	LD	A,[de]
	ORA	A
	JZ	PAD3		;LOOKING FOR BINARY 0
	MOV	M,A
	INC	HL
	INC	DE
	JMP	PAD2		;FOR ANOTHER CHAR

PAD3:	;END OF ASCII FILL (NOW RIGHT ADJUSTED IN A_SN)
;
RDDSK:	;READ DISK AND COPY
	CALL	INSMSG
	CALL	CI		;WAIT FOR RESPONSE
	space	4,10
NEXTDISK:	;Here to process new disk
	LDK	HL,0FF00h or NSEC
	STO	HL,TRKDEF	;set for single density
	LDK	A,255
	STA	STRACK		;MARK AS MOVCPM.COM NOT SERIALIZED
	CALL	CURMSG
	CALL	ASERMSG
	CALL	NEWMSG
	CALL	CI

;	NEW DISK IS READY, TRY THE COPY OPERATION
	LDK	HL,TRACK
	STO	0,[hl]		;CLEAR THE TRACK NUMBER
	LDK	HL,TRKCNT
	MVI	M,'0'
	INC	HL
	MVI	M,'0'
	page
RDTRK:	;Read the next source track and check for end of
;	data on disk by validating a track of all E5h.
	LDK	HL,IBUFF
	STO	HL,BUFFA
	CALL	RDSK
	JZ	READOK		;if NO error
	CALL	READ0MSG
	JMP	RDDSK		;try again



READOK:	;Read performed ok, now check which track
	LDA	TRACK
	CMP	CCPTRK
	JNZ	QTRK3		;if NOT correct track

;	Look for serial number on track
	LDK	HL,CCPV
	LDK	BC,SLEN
SEARCH:	PUSH	H
	PUSH	B
	LXI	D,CKEYS
	LDK	C,LKEYS

;	Loop thru data looking for match
COMP0:	LD	A,[de]		;next table entry
	CMP	[hl]		;compare to disk read
	JNZ	SRHERR		;if NO match
	INC	HL
	INC	DE
	LD	A,[de]
	CMP	[hl]
	JNZ	SRHERR
	INC	HL
	INC	DE
	DCR	C
	JNZ	COMP0

;	Match is now complete, Serial Number found.
	POP	B
	POP	D		;CLEARS STACK
	PUSH	H		;SAVE A COPY OF THE START ADDRESS OF THE SER #
	EX	DE,HL
	LD	HL,ORIGIN
	EX	DE,HL
	MOV	M,e		; low byte(origin)
	INC	HL
	MVI	M,VERSION	;VERSION NUMBER IN BINARY
	INC	HL
	mov	m,d		; high byte(origin)
	INC	HL
	Mvi	M,0		; next byte zeroed (not used yet)
	INC	HL		;READY TO ACCEPT THE SERIAL NUMBER
	EX	DE,HL
	LD	HL,B_SN
	EX	DE,HL
	MOV	M,D
	INC	HL
	MOV	M,E
;	FIRST SERIAL NUMBER IS STORED, NOW COPY TO BDOS
	POP	B
	PUSH	B
	LXI	D,BDOSV
;	COMPUTE DIFFERENCE IN ADDRESSES FOR LATER
	MOV	A,E
	SUB	C
	MOV	L,A
	MOV	A,D
	SBB	B
	MOV	H,A
	STO	HL,SDIFF
	POP	H
	LDK	C,6		;LENGTH OF SERIAL NUMBER
;	H,L ADDRESS START OF SERIAL NUMBER, D,E ADDRESS SECOND #
COPY0:	LD	A,[hl]
	STAX	D
	INC	DE
	INC	HL
	DCR	C
	JNZ	COPY0
	JMP	RDTRKN		;BDOS serial number is copied
	space	4,10
SRHERR:	;Search error, NO match, update pointers
;	and check for END of search.
	POP	B
	POP	H
	INC	HL
	DCX	B
	MOV	A,C
	ORA	B
	JNZ	SEARCH
	CALL	BADDSK		;not found
	JMP	RDDSK
	space	4,10
QTRK3:	;IS THIS TRACK 3? IF SO, LOOK FOR CPM.COM
	CPI	MOVTRK
	JNZ	RDTRKN
	LDK	HL,0		;look for Serial number
	LDK	BC,TRLEN	;TRACK LENGTH IN B,C
QTR0:	PUSH	H
	PUSH	B		;SAVE BASE ADDRESS AND LENGTH
	LXI	D,CKEYS
	LDK	C,LKEYS

QTR1:	;Check for encoded command strings in MOVCPM
	PUSH	H
	CALL	TBA
	LD	A,[de]
	CMP	[hl]
	POP	H
	JNZ	NOMAT3		;if no match
	INC	HL
	INC	DE
	PUSH	H
	CALL	TBA
	LD	A,[de]
	CMP	[hl]
	POP	H
	JNZ	NOMAT3		;if NO match
	INC	HL
	INC	DE
	DCR	C
	JNZ	QTR1		;If not done loop

;	Here if match, set serial number into MOVCPM
	POP	B
	POP	D		;TO CLEAR THE STACK
	PUSH	H		;SAVE SOURCE ADDRESS
	CALL	STOSN		;SERIAL NUMBER STORED
	POP	H		;RECALL SOURCE ADDRESS
	EX	DE,HL
	LD	HL,SDIFF
	ADD	HL,DE		;H,L SHOULD ADDRESS SER#2
	MOV	A,L
	ORA	A
	JNZ	QTR2		;MUST BE LOW ZERO
;	SETUP STRACK TO SERIALIZE WHEN PROPER TRK FOUND
	EX	DE,HL
	LDK	HL,STRACK	;DIFFERENCE IN D,E
	STO	0,[hl]		;COUNT STRACK UP FOR EACH TRACK SIZE
DLOOP:	INR	M		;STRACK = STRACK + 1
	MOV	A,E
	SUI	(26*LTRK) AND 0FFH
	MOV	B,A		;SAVE LOW ORDER DIFFERENCE
	MOV	A,D
	SBI	(26*LTRK) SHR 8
	JC	EDLOOP		;CARRY IF TOO MANY SUBTRACTS
	MOV	D,A
	MOV	E,B		;RESET TO LOWER VALUE
	JMP	DLOOP
	space	4,10
EDLOOP:	;D,E CONTAIN OFFSET INTO TRACK STRACK
	EX	DE,HL
	STO	HL,SDIFF
	JMP	RDTRKN


NOMAT3:	;NO MATCH ON CURRENT STRING
	POP	B
	POP	H
	INC	HL
	DCX	B
	MOV	A,B
	ORA	C
	JNZ	QTR0		;If not entire track, continue

;	Here on MOVCPM.com not defined correctly
QTR2:	CALL	BADCOM
	JMP	RDDSK


RDTRKN:	;CHECK FOR MOVCPM.COM SERIALIZATION
	LDK	HL,STRACK
	LD	A,[hl]
	ORA	A
	JZ	NOSER
;	ALREADY SERIALIZED IF STRACK=0
	DCR	M
	JNZ	NOSER		;NOT ON PROPER TRACK
;	ON PROPER TRACK, SDIFF CONTAINS INDEX TO BDOS SERIAL#
	LD	HL,SDIFF
	CALL	STOSN

NOSER:	;TRACK IN MEMORY, CHECK FOR LAST TRACK
	LDK	HL,IBUFF
	LDK	BC,TRLEN
TRCOMP:	LDK	A,0E5H
	CMP	[hl]
	JNZ	WRTRK
	INC	HL
	DCX	B
	MOV	A,C
	ORA	B
	JNZ	TRCOMP		;if not whole track
;END OF COPY, ALL 0E5H'S
	LDA	STRACK
	ORA	A
	JZ	ENDCOPY
;	NOT ZERO, COULD NOT FIND SECOND SER NUMBER
	CALL	BADCOM
	JMP	RDDSK


ENDCOPY:
	LXI	D,TRMSG
	CALL	OSTR
	CALL	INCSN
	JMP	NEXTDISK

;	NOT END OF COPY, WRITE TRACK TO DISK FROM IBUFF
WRTRK:	CALL	WDSK
	JZ	WROK
	CALL	WRTMG1
	JMP	NEXTDISK

WROK:	;Data written to disk, now read it back and compare.
	LDK	HL,OBUFF
	STO	HL,BUFFA
	CALL	REDSK
	JZ	VERRD		;if data read ok, verify
	CALL	RDMG1
	JMP	NEXTDISK

VERRD:	;Reading of data just written is ok, now
;	verify it is correct.
	LDK	HL,IBUFF
	LXI	D,OBUFF
	LDK	BC,TRLEN/2
	LD	A,TRKDEF
	CMP	26
	JZ	VERRD1		;if single density
	LDK	BC,TRLEN
VERRD1:	LD	A,[de]
	CMP	[hl]
	JZ	VERRD2		;if good compare
	CALL	VERERR		;indicate error
	JMP	NEXTDISK	;start again

VERRD2:	INC	HL
	INC	DE
	DCX	B
	MOV	A,C
	ORA	B
	JNZ	VERRD1

;	Compare valid, increment track count and process
;	next track
	LDK	HL,0FF00h or (NSEC*2)
	STO	HL,TRKDEF	;set for double density
	LDK	HL,TRACK
	INR	M
	LDK	HL,TRKCNT+1
	INR	M
	LD	A,[hl]
	CPI	'9'+1
	JC	RDTRK		;OVERFLOW TO HIGH ORDER TRACK NUMBER
	MVI	M,'0'
	DCX	H
	INR	M
	JMP	RDTRK
	page
;	Utility Routines



CI:	LDK	C,CONIN
	JMP	BDOS		;READ A CHARACTER

OSTR:	LDK	C,PBUFF
	JMP	BDOS		;PRINT A BUFFER

GNUME:	;Here on number input error, output message
;	and try again
	CALL	INVALID		;indicate bad number

GNUM:	;Get number from user
;	Exit	BC = number in binary
	proc
	LXI	D,MAXLEN
	LDK	C,RDBUFF
	CALL	BDOS		;BUFFER FILLED
	LDK	HL,COMLEN
	LD	A,[hl]
	ORA	A
	JZ	GNUME		;NON ZERO LENGTH
	INC	HL
	MOV	E,A
	LDK	D,0
	ADD	HL,DE		;H,L ADDRESS LAST POS+1
	STO	0,[hl]		;CLEARED FOR END OF SCAN
	LDK	HL,CBUFF
	LDK	BC,0
:2:	LD	A,[hl]
	ORA	A
	RZ			;if end of conversion
	SUI	'0'
	CPI	10
	JNC	GNUME
	PUSH	H
	PUSH	B
	POP	H		;B,C COPIED TO H,L
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	PUSH	H
	POP	B
	POP	H		;BC=BC*10
	INC	HL
	ADD	C
	MOV	C,A
	LDK	A,0
	ADC B
	MOV	B,A
	JC	GNUME
	JMP	:2		;TESTED FOR OVERFLOW
	space	4,10
INCSN:	;Increment Serial Number
	LD	HL,B_SN
	INC	HL
	STO	HL,B_SN		;TEST FOR OVERFLOW
	MOV	A,L
	ORA	H
	JZ	SEROVER
;
	LDK	HL,A_SN+4
	LDK	B,5		;LENGTH OF SERIAL NUMBER
INC0:	INR	M
	LD	A,[hl]
	CPI	'9'+1
	RC			;RETURN IF NO CARRY
	MVI	M,'0'		;CLEAR THE NUMBER
	DCX	H
	DCR	B
	JNZ	INC0
SEROVER:	;OVERFLOW IN SERIAL NUMBER
	CALL	OVERMSG
	JMP	BOOT
	space	4,10
TBA:	;TRANSLATE THE RELATIVE ADDRESS IN H,L TO ABSOLUTE ADDRESS
;	IN IBUFF, ASSUMING SECTORS ARE SKEWED
	PUSH	D
	MOV	A,L
	ANI	7FH
	MOV	E,A		;LS 7 BITS OF ADDRESS SAVED
	MOV	A,L
	RAL			;CARRY GETS MSB
	MOV	A,H
	RAL			;CARRY GOES TO LSB
	MOV	L,A
	LDK	H,0		;H,L CONTAIN INDEX INTO TRANSLATE TABLE
	PUSH	D
	LXI	D,TRAN
	ADD	HL,DE		;Set HL to sector data is in
	POP	D

;	Now convert sector address to memory address
	XRA	A
	LD	A,[hl]
;	DEC	A		;** all numbers are relative to 0
	RAR			;CARRY GETS LSB, MSB=0
	MOV	H,A
	LDK	A,0
	RAR			;CARRY GOES TO MSB
	ORA	E		;RECLAIM THE LEAST SIGNIFICANT 7 BITS
	MOV	L,A
	LXI	D,IBUFF
	ADD	HL,DE		;ABSOLUTE ADDRESS IN H,L
	POP	D		;RECALL STACKED D VALUE
	RET
	space	4,10
STBYTE:	;STORE BYTE VALUE GIVEN BY REGISTER A TO TRANSLATED
;	ADDRESS GIVEN BY H,L.  INCREMENT H,L UPON RETURN
	PUSH	H
	PUSH	D
	PUSH	PSW
	CALL	TBA
	POP	PSW
	MOV	M,A
	POP	D
	POP	H
	INC	HL
	RET
	space	4,10
STOSN:	;STORE THE SERIAL NUMBER INTO ADDRESS GIVEN BY H,L
	LDA	ORIGIN
	CALL	STBYTE		;BYTE STORED, H,L INCREMENTED
	LDK	A,VERSION
	CALL	STBYTE		;VERSION NUMBER
	LDA	ORIGIN+1
	CALL	STBYTE		;stuff high (origin)
	XRA	A
	CALL	STBYTE		;ZERO BYTE

;	Now move serial number to last two bytes
	LXI	D,B_SN+1	;ADDRESS HIGH ORDER POSITION OF SER #
	LD	A,[de]
	CALL	STBYTE
	DCX	D		;ADDRESS LOW ORDER BYTE
	LD	A,[de]
	CALL	STBYTE
	RET
	page
;	All ERROR Messages


;	PRINT STRINGS
INSMSG:
	LXI	D,$+6
	JMP	OSTR
	DB	cr,lf,lf,lf,'INSERT *MASTER* disk in A:, type RETURN$'

ORGMSG:	proc
	LXI	D,:1
	JMP	OSTR
:1:	DB	cr,lf
	DB	'CP/M - CompuPro Version '
	DB	VERSION/10+'0','.',VERSION MOD 10 +'0'
	DB	' Serialization,',cr,lf
	DB	'Your OEM distribution code number --'
	DB	OEMN1,OEMN2,OEMN3,'--$'

SERMSG:	LXI	D,$+6
	JMP	OSTR
	DB	cr,lf,'STARTING serial Number is $'
;
INVALID:
	LXI	D,$+6
	JMP	OSTR

	DB	cr,lf,'INVALID NUMBER, TRY AGAIN $'
;
CURMSG:
	LXI	D,$+6
	JMP	OSTR

	DB	cr,lf,'Serializing Disk number      $'

ASERMSG:
	LXI	D,OEMNUM
	CALL	OSTR
	LXI	D,A_SN
	JMP	OSTR

NEWMSG:
	LXI	D,$+6
	JMP	OSTR
	DB	cr,lf,lf,'Insert NEW disk in drive B:, Type RETURN$'

BADCOM:	proc
	LXI	D,:1
	JMP	OSTR
:1:	DB	cr,lf,'BAD MOVCPM.COM FILE, REPLACE$'

BADDSK:	proc
	LXI	D,:1
	JMP	OSTR
:1:	DB	cr,lf,'NON CP/M DISKETTE, CANNOT SERIALIZE$'

VERERR:	proc
	LXI	D,:1
	JMP	OSTR
:1:	DB	cr,lf,'VERIFICATION ERROR, BAD DISK$'

OVERMSG:
	LXI	D,$+6
	JMP	OSTR
	DB	cr,lf,'SERIAL NUMBER OVERFLOW$'

READ0MSG:
	LXI	D,$+6
	JMP	OSTR
	DB	cr,lf,'ERROR ON SOURCE DISK, REPLACE$'

WRTMG1:	proc
	LXI	D,:1
	JMP	OSTR
:1:	DB	cr,lf,'CANNOT WRITE NEW DISK, REPLACE$'

RDMG1:	proc
	LXI	D,:1
	JMP	OSTR
:1:	DB	cr,lf,'CANNOT RE-READ NEW DISK, REPLACE$'
	page
;	MISCELLANEOUS DATA AREAS
;
ORIGIN:	DS	2	;BINARY ORIGIN
AORIG:	DB	cr,lf
OEMNUM:	DB	OEMN1,OEMN2,OEMN3,' - $'
TRMSG:	DB	cr,lf
TRKCNT:	DB	'00 Tracks copied and Verified'
	DB	cr,lf,'   End of copy'
	DB	cr,lf,'---------------------------------------$'

B_SN:	DS	2	;BINARY SERIAL NUMBER
A_SN:	DB	'00000$'


CKEYS:	;Command keys incoded
	DB	'DIR '
	DB	'ERA '
	DB	'TYPE'
	DB	'SAVE'
	DB	'REN '
	DB	'USER'
LKEYS	EQU	(*-CKEYS)/2


;	Input buffer
MAXLEN:	DB	7
COMLEN:	DS	1
CBUFF:	DS	8
STRACK:	DS	1	;SERIALIZE TRACK FOR CPM.COM FILE WHEN ENCOUNTERED
SDIFF:	DS	2	;DIFFERENCE BETWEEN TWO SERIAL NUMBER ADDRESSES


;	Sector translation table.
;	Defined for 256 byte sectors
;	Must match CBIOS implementation.
TRAN:	DB	 0,  1, 18, 19, 36, 37,  2,  3, 20, 21, 38, 39
	DB	 4,  5, 22, 23, 40, 41,  6,  7, 24, 25, 42, 43
	DB	 8,  9, 26, 27, 44, 45, 10, 11, 28, 29, 46, 47
	DB	12, 13, 30, 31, 48, 49, 14, 15, 32, 33, 50, 51
	DB	16, 17, 34, 35

TRKDEF:	DW	0	;track-sector definition


	DS	20*2	;STACK
STACK:	DS	0


IBUFF:	DS	TRLEN
OBUFF:	DS	TRLEN
CCPV	EQU	IBUFF+OFFSET
BDOSV	EQU	IBUFF+(BDOSB-CCPB)+OFFSET


	END
